import stdlib.*;
import rocketvale.*;
import valejson.*;
import stdlib.stringutils.*;
import atharia.model.*;
import atharia.model.animation.*;
import atharia.network.*;


struct Response {
  builder StringBuilder;
}

fn jsonToNode(s StrSlice) Result<JsonNode, str> {
  iter = ParseIter(s, false);
  node_result = parseJson(&!iter);
  if (node_result.is_err()) {
    ret node_result;
  }
  if (iter.rest != "".slice()) {
    ret Err<JsonNode, str>("Still text at end of input: " + iter.rest);
  }
  ret node_result;
}

struct StartRequest {
  screen_gw int;
  screen_gh int;
}

fn handleStartRequest(domino &!GameToDominoConnection, start_request &StartRequest) Result<[], str> {
  pattern = make_pentagon_9_pattern();

  cameraLookAtPosition =
      pattern.getTileCenter(Location(0, 0, 0)).Vec3i(0); //terrain.GetTileCenter(startLocation);
  lookatOffsetToCamera = Vec3i(0, 5000, -10000);

  domino!.setup_game(
      cameraLookAtPosition,
      lookatOffsetToCamera,
      200,
      pattern);

  initialTileDescription =
      InitialTile(
          Location(0, 0, 0),
          6,
          ConstantVec4iAnimationRed(), //CalculateTintedFrontColor(membersFrontColors[membersFrontColors.Count - 1].Item2, selected, highlighted),
          ConstantVec4iAnimationBlue()); //membersSideColors[membersSideColors.Count - 1].Item2,
          //CalculateMaybeOverlay(membersOverlays),
          //CalculateMaybeFeature(membersFeatures),
          //membersItems);
  tileViewId = domino!.create_tile(initialTileDescription);

  ret Ok<[], str>([]);
}

fn handleEvent(domino &!GameToDominoConnection, node &JsonObject) Result<[], str> {
  maybe_event_type_str = expect_obj_member_str(node, "event_type");
  if (maybe_event_type_str.is_err()) {
    ret Err<[], str>(maybe_event_type_str.expect_err());
  }
  event_type_str = maybe_event_type_str.expect();

  if (event_type_str == "Start") {
    maybe_screen_gw = expect_obj_member_int(node, "screen_grid_width");
    if (maybe_screen_gw.is_err()) {
      ret Err<[], str>(maybe_screen_gw.expect_err());
    }
    screen_gw = maybe_screen_gw.expect();

    maybe_screen_gh = expect_obj_member_int(node, "screen_grid_height");
    if (maybe_screen_gh.is_err()) {
      ret Err<[], str>(maybe_screen_gh.expect_err());
    }
    screen_gh = maybe_screen_gh.expect();

    request = StartRequest(screen_gw, screen_gh);
    ret handleStartRequest(domino, &request);
  } else {
    ret Err<[], str>("Unknown request type: " + event_type_str);
  }
}

struct MyRequestHandler {
  counter! int;
}
impl IRequestHandler for MyRequestHandler;
fn handle(self &!MyRequestHandler impl IRequestHandler, request_path str, request_json str) str {
  maybe_request_root_node = jsonToNode(request_json.slice());
  if (maybe_request_root_node.is_err()) {
    ret "Couldn't parse request: " + maybe_request_root_node.expect_err();
  }
  request_root_node = (maybe_request_root_node).expect();

  maybe_request_root_obj = request_root_node.as<JsonObject>();
  if (maybe_request_root_obj.is_err()) {
    ret "Request wasn't json object!";
  }
  request_root_obj = maybe_request_root_obj.expect();

  domino = GameToDominoConnection();
  result = handleEvent(&!domino, &request_root_obj);
  if (result.is_err()) {
    ret "Error: " + result.expect_err();
  }

  commands_json_arr =
      JsonArray(
        [vary *](
            domino.commands.len(),
            &!{ domino.commands.get(_).JsonNode() }));
  response_obj = JsonObject();
  response_obj.fields!.add("commands", commands_json_arr);

  drop(domino);

  set self.counter = self.counter + 1;

  ret "Response: " + response_obj.str();
}

fn main() export {
  runServer(&MyRequestHandler(0));
}
