
struct UnitPresenter {
  domino &!GameToDominoConnection;
  unit &!Unit;

  unitViewId! i64;
}

func UnitPresenter(
  domino &!GameToDominoConnection,
  unit &!Unit)
UnitPresenter {
  unitViewId =
      domino!.CreateUnit(
          InitialUnit(
            unit.location,
            InitialSymbol(
                InitialSymbolGlyph(
                    SymbolId("AthSymbols", 123),
                    ConstantVec4iAnimation(Vec4i(128, 0, 0, 255))),
                Some(
                    InitialSymbolOutline(
                        CenteredOutline(),
                        ConstantVec4iAnimation(Vec4i(255, 0, 0, 255)))),
                None<InitialSymbolSides>(),
                0,
                100),
            InitialSymbol(
                InitialSymbolGlyph(
                    SymbolId("AthSymbols", 120),
                    ConstantVec4iAnimation(Vec4i(255, 255, 255, 380))),
                Some(
                    InitialSymbolOutline(
                        CenteredOutline(),
                        ConstantVec4iAnimation(Vec4i(0, 0, 0, 255)))),
                None<InitialSymbolSides>(),
                0,
                100),
            List<(i64, InitialSymbol)>(),
            100,
            100));

  self = UnitPresenter(domino, unit, unitViewId);

  ret self;
}

func HopTo(self &!UnitPresenter, server &!EditorInstance, newLoc Location, newElevation int) {
  //if server.locToUnit.ContainsKey(self.unit.location) {
    println("locToUnit.remove {self.unit.location}");
    server.locToUnit!.remove(self.unit.location);
  //} else {
  //  println("locToUnit.contains {self.unit.location} was false!");
  //}
  println("unoccupiedWalkableLocs.add {self.unit.location}");
  server.unoccupiedWalkableLocs!.add(self.unit.location);
  set self.unit.location = newLoc;
  set self.unit.elevation = newElevation;
  self.domino!.UnitHopTo(self.unitViewId, newLoc, newElevation);
  //if server.unoccupiedWalkableLocs.contains(self.unit.location) {
    println("unoccupiedWalkableLocs.remove {self.unit.location}");
    server.unoccupiedWalkableLocs!.remove(self.unit.location);
  //} else {
  //  println("unoccupiedWalkableLocs.contains {self.unit.location} was false!");
  //}
  println("locToUnit.add {self.unit.location}");
  server.locToUnit!.add(self.unit.location, self.unit);
}

func Act(self &!UnitPresenter, server &!EditorInstance) {
  println("unit {self.unit.id} acting!");

  path =
      Go(
          &server.terrainController.terrain.pattern,
          self.unit.location,
          server.player.get().location,
          true,
          (a, b, distanceSoFar) => {
            if distanceSoFar > 10000 {
              ret false;
            }
            server.unoccupiedWalkableLocs.contains(b) and
            server.terrainController.terrain.pattern.IsAdjacent(a, b, false)
          });
  maybeNextStepLoc Opt<Location> =
    if path.len() > 0 {
      if server.unoccupiedWalkableLocs.contains(path.get(0)) {
        x Opt<Location> = Some(path.get(0));
        x
      } else {
        // do nothing
        x Opt<Location> = None<Location>();
        x
      }
    } else {
      adjacents =
          server.terrainController.terrain.GetAdjacentExistingLocations(
              self.unit.location, false);
      possibleWanderLocs = List<Location>();
      foreach adjacent in adjacents {
        if server.unoccupiedWalkableLocs.contains(adjacent) {
          possibleWanderLocs!.add(adjacent);
        }
      }
      if possibleWanderLocs.len() == 0 {
        // do nothing
        x Opt<Location> = None<Location>();
        x
      } else {
        index = abs(TruncateI64ToI32(server.rand!.Next())) mod possibleWanderLocs.len();
        wanderLoc = possibleWanderLocs.get(index);
        x Opt<Location> = Some(wanderLoc);
        x
      }
    };

  if not maybeNextStepLoc.isEmpty() {
    nextStepLoc = maybeNextStepLoc.get();

    nextStepElevation =
        server.terrainController.terrain.tiles.get(nextStepLoc).get().elevation;

    self!.HopTo(server, nextStepLoc, nextStepElevation);
  }
}
