

func GameLoop(server &!EditorInstance) {
  remainingIterations = server.unitPresenters.len() * 3 + 100;

  dyingUnits = List<(Unit, UnitPresenter)>();

  while
      maybeNextActingUnit = FindNextActingUnit(server);
      not maybeNextActingUnit.isEmpty() {
    if remainingIterations == 0 {
      println("Hit the maximum number of iterations, exiting!");
      break;
    }
    set remainingIterations = remainingIterations - 1;

    nextActingUnit = (maybeNextActingUnit).get();
    println("At {server.gameTime} found next acting unit: {nextActingUnit.id} at {nextActingUnit.nextActionTime}");
    if nextActingUnit.hp <= 0 {
      if nextActingUnit.id == server.player.get().id {
        server.lookPanelView!.SetStuff(true, "You have died, game over!", "", List<(InitialSymbol, str)>());
        break;
      } else {
        println("Unit dying: {nextActingUnit.id}");
        dyingUnits!.add((
            server.units!.remove(nextActingUnit.id),
            server.unitPresenters!.remove(nextActingUnit.id)));
      }
    } else if nextActingUnit.id == server.player.get().id {
      // We will move the player either on their input or on the Timer request.
      break;
    } else {
      nextActingUnit!.Act(server);
    }
  }

  drop_into((dyingUnits).toArray(), &!([unit, presenter]) => {
    println("Killing unit: {unit.id}");
    server.locToUnit!.remove(unit.location);
    server.unoccupiedWalkableLocs!.add(unit.location);
    OnUnitDeath(presenter, server);
    unit;
  });

  if server.units.len() == 1 {
    server.lookPanelView!.SetStuff(true, "You have killed all the goblins, victory!", "", List<(InitialSymbol, str)>());
  }
}

func FindNextActingUnit(server &!EditorInstance) Opt<&!Unit> {
  maybeNextActingUnit Opt<&!Unit> = None<&!Unit>();

  foreach [id, unitPresenter] in &!server.unitPresenters {
    if unitPresenter.unit.nextActionTime <= server.gameTime {
      if maybeNextActingUnit.isEmpty() or
          unitPresenter.unit.nextActionTime < maybeNextActingUnit!.get().nextActionTime {
        set maybeNextActingUnit = Some(unitPresenter.unit);
      }
    }
  }

  ret maybeNextActingUnit;
}

func ProceedPlayer(server &!EditorInstance) {
  player = &!server.player!.get();
  println("Proceeding player! game time {server.gameTime} player enxt action time {player.nextActionTime}");

  destination = player.maybeDestination.get("Can't proceed, no destination!");

  path =
      Go(
          &server.terrainController.terrain.pattern,
          player.location,
          destination,
          true,
          (a, b, distanceSoFar) => {
            server.unoccupiedWalkableLocs.contains(b) and
            server.terrainController.terrain.pattern.IsAdjacent(a, b, false)
          });
  if path.len() > 0 {
    nextStepLoc = path.get(0);
    println("There is indeed a path to {destination}, length {path.len()} next step {nextStepLoc}");
    nextStepElevation =
        server.terrainController.terrain.tiles.get(nextStepLoc).get().elevation;
    player!.HopTo(server, nextStepLoc, nextStepElevation);
    println("Setting game time from {server.gameTime} to {player.nextActionTime}");

    [x, y] = server.terrainController.terrain.pattern.GetTileCenter(nextStepLoc);
    z = nextStepElevation * server.terrainController.elevationStepHeight;
    pos = Vec3i(x, y, z);
    server.domino!.MoveCamera(pos, server.lookatOffsetToCamera, 1000);

    if nextStepLoc == destination {
      println("Player reached destination, stopping!");
      set player.maybeDestination = None<Location>();
    }
  } else {
    println("No path to {destination}, stopping!");
    set player.maybeDestination = None<Location>();
  }
}
